<!-- What’s the difference between an Angular Component and Module?
Component: In Angular, a Component is a piece of code that represents a view.
 It is responsible for rendering the content and handling user interactions with the view.
  A Module is a container for a group of related components and directives. 

A Component is a class with an associated template that defines a view. 
A component controls a part of the screen called a view, which is defined by a 
class that controls the view through its template. 

. The Component class is the logic behind the view, 
and it is responsible for handling user interactions,
 updating the data model, and interacting with other components or services.
 view through an API of properties and methods exposed by the component.

<hr>
when we create a component in order to use it. We use it's selector
as an html element .And wherever we use the selector of a component like an html element  .
There some html get rendered
That html is called the view tempelate of a component.
The view tempelate of a component is a form of HTML that tells angular how 
to render a component
<hr>
When we want to display some data in the html element (or value of a variable ) 
we use string Interpolationbut when we want to assign some dynamic 
values to an html attribute ["check, disabled , hidden] we use property binding.
We use property binding for binding HTML properties with component class properties.

<hr>
Attribute binding or difference between html attribute and html property
html attribute represents the initial value and it doesn't change.

[attr.aria-hidden]=""
<hr>
Event Binding allows us to bind webpage events to a components property 
or methods . Using Event Binding we can pass data from view to component
Event binding :(data)="expression"
<hr>
Two way data binding binds data from component class to view tempelate and view tempelate 
to component class . This is a combination of property binding and event binding 
<hr>
custom property binding

=>we can pass data from parent component to child component using @Input decorator.
=>we also call it custom property binding because here we bind the custom properties
of child component class with the property or method of parent component class
<hr>
Type of component selector
so far we have seen that we can use the selector of a component like a html tag
so wherever we will use that selector like html tag there
 the view tempelte of that component will be rendered,but we can also use a component 
 selector in different ways for example we have already seen that we use use selector 
 like a html tag but we can also use a selector like a html atrribute or css class

 HTML Tag  
 selector:"app-nav"
 <app-nav></app-nav>

 HTML attribute
 selector:"[app-nav]"
 <div app-nav ></div>

 HTML class
 selector:".app-nav"
<div class="app-nav"></div>

<hr>
A directive is an Instruction to DOM. In simple words we 
use directives to manipulate the DOM
Using directive we tell angular how the DOM element should behave or
 look like and also which DOM elemenmt to add to the web page and 
 which one to not add . we can change DOM elements appearance Behaviour
  or layout using directives they simply help you to extend HTML in some way

Directives in angular can be classified into three types
COMPONENT DIECTIVE, Attribute Directive, Structural Directive

A componemnt directive is the angular component. It is a directive with a tempelate
A component directive is nothing but components in angular.
Components are also a kind of instructions to DOM . 
wherever we use a component there we instruct
angular to render the view tempelate of that copmponent.

once we place the selector of our component somewhere in the tempelate 
at this point of time  we are instructing angular to add the content of our
components view tempelate and the business logic of the typescript code
in that place where we have used the selector of that component.

Attribute Directives:
These directives change the appearance or behavior of an element.
Examples include [ngClass], [ngStyle], and custom attribute directives
( to encapsulate and reuse behavior across Angular application).


A structural directive is a directive that changes the structure of the DOM by adding
 or removing elements. Structural directives allow you to control the layout and display
  of elements in a flexible way, often based on conditions or collections.

Structural directives are unique in that they use an asterisk (*) prefix and can 
dynamically insert, remove, or manipulate elements within the DOM. When Angular 
sees the asterisk, it interprets the directive as needing to create or alter 
a new embedded view based on the directive's logic.

*ngIf: Conditionally includes or excludes an element based on a boolean expression.

<div *ngIf="isVisible">This is displayed if isVisible is true.</div>
If isVisible is false, Angular removes this <div> from the DOM.

  
*ngFor: Repeats an element for each item in a list.
<div *ngFor="let item of items">{{ item }}</div>
If items is an array, Angular creates one <div> for each item.


*ngSwitch: Displays different templates based on the current value of a variable.\
<div [ngSwitch]="status">
  <p *ngSwitchCase="'success'">Success</p>
  <p *ngSwitchCase="'error'">Error</p>
  <p *ngSwitchDefault>Unknown status</p>
</div>


<hr>
life cycle hooks

The Angular lifecycle hooks are the methods that angular invokes on the
 directives and components as it creates, changes, and destroys them.

When the angular application starts, it first creates and renders the root component. 
Then, it creates and renders its Children's & their children. It forms a tree of components
Once Angular loads the components, it starts the process of rendering the view.
 =>To do that, it needs to check the input properties,
  evaluate the data bindings & expressions, render the projected content etc.
=>Angular lets us know when these events happen using lifecycle hooks. For Example:
ngOnInit when Angular initializes the component for the first time.
=>When a component's input property change, Angular invokes ngonChanges
If the component is destroyed, Angular invokes ngOnDestroy

Constructor of a Component

Life Cycle of a component begins, when Angular creates the component class.
 First method that gets invoked is class Constructor.

Constructor is neither a life cycle hook nor it is specific to Angular.
 It is a JavaScript feature It is a method which gets invoked, when a class is created.

When a constructor is called, at that point, none of the components input properties
 are updated and available to use. Neither its child components are constructed. 
 Projected contents are also not available.

Once Angular instantiates the class, it kick-start the first change detection cycle of the component.


read from pdf
<hr>
Change detection is the mechanism by which angular keeps the template in sync with the component.
Class decorators, eg @Component and @NgModule
Property decorators for properties inside classes, eg @Input and @Output
Method decorators for methods inside classes, e g.
 @HostListener Parameter decorators for parameters inside class constructors, eg @inject


Dependencies are services or objects that a class needs to perform its function.
 DI is a coding pattern in which a class asks for dependencies from
  external sources rather than creating them itself.

  A provider is an object declared inside decorators which inform Angular
   that a particular service is available for Injecting inside the components.


  <hr>

A Service is a reusable TypeScript class that can be used in multiple components across your Angular application

Operators in Rxjs are functions that takes an observable as input and transform it into a new observable
 and return it. We use operators to manipulate the observable data stream
<hr>
The @ContentChild  is a decorator, which we use to  get/access the html element ,components and directives 
 from the view tempelate of the parent component to the component class of the child component
 


Dependency Injection (DI) is a design pattern and a software architectural 
concept widely used in software development, including frameworks like Angular,
 Spring (Java), and others. The core idea behind Dependency Injection is to separate
  the creation and management of a class's dependencies from the class itself.

In simpler terms:

Dependencies:

In a software system, a class often relies on other classes or services to perform certain tasks.
 These external components that a class depends on are called "dependencies."
Injection:

Instead of a class creating its dependencies directly, Dependency Injection involves
 injecting (providing) the required dependencies from the outside.
Inversion of Control (IoC):

Dependency Injection is a form of Inversion of Control. In a traditional approach,
 a class controls the creation of its dependencies. With DI,
  the control is inverted – the responsibility for providing dependencies is moved outside the class.




  The Angular lifecycle hooks are the methods that angular invokes on the
 directives and components as it creates, changes, and destroys them.

When the angular application starts, it first creates and renders the root component. 
Then, it creates and renders its Children's & their children. It forms a tree of components
Once Angular loads the components, it starts the process of rendering the view.
 =>To do that, it needs to check the input properties,
  evaluate the data bindings & expressions, render the projected content etc.
=>Angular lets us know when these events happen using lifecycle hooks. For Example:
ngOnInit when Angular initializes the component for the first time.
=>When a component's input property change, Angular invokes ngonChanges
If the component is destroyed, Angular invokes ngOnDestroy



ngOnChanges: This lifecycle hook is executed whenever the component's input properties change.
ngOnInit: This lifecycle hook is executed after the component's constructor 
method and is a good place to perform initial setup for the component.

ngDoCheck: This lifecycle hook is executed during every change detection 
cycle and is a good place to perform custom change detection.

ngAfterContentInit: This lifecycle hook is executed after the component's
 content has been initialized and is a good place to perform additional setup for the component's content.


ngAfterContentChecked: This lifecycle hook is executed after the component's
 content has been checked and is a good place to perform additional operations based on the component's content.


ngAfterViewInit: This lifecycle hook is executed after the component's
 view has been initialized and is a good place to perform additional
  setup for the component's view.


ngAfterViewChecked: This lifecycle hook is executed after the component's 
view has been checked and is a good place to perform additional
 operations based on the component's view.


ngOnDestroy: This lifecycle hook is executed just before the 
component is destroyed and is a good place to perform 
cleanup operations for the component.


https://www.youtube.com/watch?v=jJ5a1dBxfno








 -->
<!-- Copy everything within the <div> to get all explanations -->

  <div>
    <b>Property Binding:</b> Property binding in Angular is used to bind data from a component to an element property in the view template. The data flows in one direction, from the component to the DOM.<br>
    Example:<br>
    <input [value]="name"><br>
    Here, the value of the input element is set to the component's `name` property.<br><br>
    
    <b>Interpolation / innerHTML:</b> Interpolation allows you to embed expressions within the HTML template. It is represented by double curly braces `{{}}`.<br>
    Example:<br>
    <p>{{message}}</p><br>
    The content of the `<p>` element is set to the value of the `message` property from the component.<br><br>
    
    <b>Value Binding:</b> Value binding binds the value attribute of an HTML element to a property in the component.<br>
    Example:<br>
    <input [value]="username"><br>
    The input element's value is bound to the `username` property in the component.<br><br>
    
    <b>Attribute Binding:</b> Attribute binding is used to bind a value to an attribute of an HTML element. This is done using the `attr` prefix.<br>
    Example:<br>
    <td [attr.colspan]="colspan"></td><br>
    The `colspan` attribute of the `<td>` element is bound to the `colspan` property in the component.<br><br>
    
    <b>Style Binding:</b> Style binding binds a style property of an HTML element to a property in the component. This is done using the `style` prefix.<br>
    Example:<br>
    <div [style.background-color]="bgColor"></div><br>
    The background color of the `<div>` element is bound to the `bgColor` property in the component.<br><br>
    
    <b>Event Binding:</b> Event binding allows you to bind events to methods in your component. This is done using parentheses `()`.<br>
    Example:<br>
    <button (click)="handleClick()">Click me</button><br>
    The `click` event of the `<button>` element is bound to the `handleClick` method in the component.<br><br>
    
    <b>One Way Binding:</b> One-way binding updates the view with data from the component. This means changes in the component are reflected in the view, but not the other way around.<br>
    Example:<br>
    <p>{{name}}</p><br>
    The `<p>` element displays the value of the `name` property from the component.<br><br>
    
    <b>Two Way Binding:</b> Two-way binding allows synchronization of data between the component and the view. This is achieved using the `ngModel` directive.<br>
    Example:<br>
    <input [(ngModel)]="name"><br>
    The value of the `name` property in the component and the value of the input field are synchronized.<br><br>
    
    <b>(click)=callfun():</b> Event binding for the click event, calling the `callfun` function when the button is clicked.<br>
    Example:<br>
    <button (click)="callfun()">Click me</button><br><br>
    
    <b>(keydown.space)=onSpacebarDownEvent():</b> Event binding for the keydown event when the spacebar is pressed, calling the `onSpacebarDownEvent` function.<br>
    Example:<br>
    <input (keydown.space)="onSpacebarDownEvent()"><br><br>
    
    <b>(on-click)=onButtonClick():</b> Incorrect syntax. Correct event binding should use parentheses:<br>
    Example:<br>
    <button (click)="onButtonClick()">Click me!</button><br><br>
    
    <b>dragover:</b> Event binding for the dragover event, calling the specified function when the dragged item is over the element.<br>
    Example:<br>
    <div (dragover)="onDragOver($event)"></div><br><br>
    
    <b>dbclick:</b> Event binding for the double-click event, calling the specified function when the element is double-clicked.<br>
    Example:<br>
    <button (dblclick)="onDoubleClick()">Double click me</button><br><br>
    
    <b>drag:</b> Event binding for the drag event, calling the specified function when the element is being dragged.<br>
    Example:<br>
    <div (drag)="onDrag($event)"></div><br><br>
    
    <b>blur:</b> Event binding for the blur event, calling the specified function when the element loses focus.<br>
    Example:<br>
    <input (blur)="onBlur()"><br><br>
    
    <b>focus:</b> Event binding for the focus event, calling the specified function when the element gains focus.<br>
    Example:<br>
    <input (focus)="onFocus()"><br><br>
    
    <b>scroll:</b> Event binding for the scroll event, calling the specified function when the element is scrolled.<br>
    Example:<br>
    <div (scroll)="onScroll($event)"></div><br><br>
    
    <b>keydown:</b> Event binding for the keydown event, calling the specified function when a key is pressed.<br>
    Example:<br>
    <input (keydown)="onKeyDown($event)"><br><br>
    
    <b>keyup:</b> Event binding for the keyup event, calling the specified function when a key is released.<br>
    Example:<br>
    <input (keyup)="onKeyUp($event)"><br><br>
    
    <b>[ngSwitch]:</b> Directive that conditionally swaps the DOM structure based on a value.<br>
    Example:<br>
    <div [ngSwitch]="condition"><br>
      <p *ngSwitchCase="1">Case 1</p><br>
      <p *ngSwitchCase="2">Case 2</p><br>
      <p *ngSwitchDefault>Default case</p><br>
    </div><br><br>
    
    <b>[ngClass]:</b> Directive that adds or removes CSS classes based on component state.<br>
    Example:<br>
    <div [ngClass]="{active: isActive}">Content</div><br><br>
    
    <b>[ngStyle]:</b> Directive that adds or removes inline styles based on component state.<br>
    Example:<br>
    <div [ngStyle]="{'font-size.px': fontSize}">Styled text</div><br><br>
    
    <b>ngNonBindable:</b> Directive that tells Angular not to compile or bind the content of the element.<br>
    Example:<br>
    <div ngNonBindable>{{text}}</div><br>
    The content inside the `<div>` is not compiled or bound by Angular, so it displays `{{text}}` as is.<br><br>
    </div>
    
    <button onclick="copyToClipboard(this)">Copy All</button>
    <script>
    function copyToClipboard(button) {
        const content = button.previousElementSibling.innerText;
        navigator.clipboard.writeText(content);
    }
    </script>
    