<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
  <h1>A function which is using another function as a parameter or
     returning a function is known as HOF</h1>
    <h1>Higher Order Function</h1>
    <p>
        array -> forEach   -> not an array
        array -> map       -> array
       array -> filter    -> array
       array -> reduce    -> single value
       
       
       forEach().map() --> N 
       map().forEach() --> Y
       filter().reduce() --> Y
       map().filter() --> Y
       forEach().filter() -> N 
    </p>
</body>
<script>
    // let arr=[1238765]
// let n=arr.toString()
// let bag=""
// for(let i=0;i<=n.length-1;i++){
//     bag=" "+n[i]+bag
// }


// console.log(bag)
// let a=5
// let b=7
// [a,b]=[b,a]
// console.log(a,b)
// function map(arr){
// let obj={}
// for(let i=0;i<=arr.length-1;i++){
//     if(obj[arr[i]]==undefined){
//         obj[arr[i]]=1
//     }else{
//         obj[arr[i]]++
//     }
// }
// console.log(obj)
// }




// map([1,2,2,2,3,4,5,5,6])

// let arr=[1,2,3,4,4,5,6,7]
// arr1=arr.map(x=>x*2)
// console.log(arr1)

// let arr=[1,2,3,4,4,5,6,7]
// arr1=arr.filter(el=>el%2==0)
// console.log(arr1)



// let arr=[1,2,3,4,4,5,6,7]
// arr.forEach((el,i,y)=>{
//     console.log(i,el*2,y)
// })

// let ar=[1,2,3,4,4,5,6,7]
// arr1=ar.map(x=>x*2)
// console.log(arr1)   //2 4 6 8 8   10 12 14

// let ar=[1,2,3,4,4,5,6,7]
// arr1=ar.forEach(x=>x*2)
// console.log(arr1) //undefined it returns undefined



////
// let array=[1,2,3,4]
// let reducefn=array.reduce(function(acc,el,i,arr){
//     return acc+el
// })
// console.log(reducefn)


let array=[1,2,3,4]
let reducefn=array.reduce((acc,el,i,arr)=>acc+el)
console.log(reducefn)
</script>
<script>

let array1=[1,2,3,4]
let reducefn1=array1.reduce((acc,el,i,arr)=>{
    acc=acc*el
     return acc},)
console.log(reducefn1)
</script>


<script>
    var mobiles=[
  {brand:"Samsung",model:"S7562"},
  {brand:"Apple",model:"iphone 13 pro"},
  {brand:"one plus",model:"7 pro"}
]
mobiles.forEach(function(elem){
  console.log(elem.model)
})
var out = mobiles.map(function(elem){
  return elem.model
})
console.log(out)

</script>


<script>
// Given an array of numbers find the sum of cubes if the number is divisible 
// by 3 Sample Input - [1, 2, 3, 4, 5, 6] Sample Output - 243 (27+216)
let arr =[1,2,3,4,5,6]
var out = arr.filter((el)=>{
  return el%3==0
}).reduce(function(acc,ele){
  return acc+ele**3
},1)

</script>

<script>

//   let developers_array=[
//     {first:"John",last:"Doe",Dept:"FE"},
//      {first:"ohn",last:"Foe",Dept:"ECE"},
//      {first:"Rohn",last:"Xoe",Dept:"ME"}
// ]
// //expected op 
// //let eng=["John Doe","ohn Foe","Rohn Xoe"]


// let eng=developers_array.reduce((acc,item)=>{
//     let fullName=item.first+' '+item.last;
//     acc.push(fullName)
//     return acc;
// },[])
// console.log(eng)


// ///
// let engineers=developers_array.map((el)=>{
// return el.first+" "+el.last})
// console.log(engineers)
                                   
// ///
// let engineers=developers_array.map(el=>el.first+" "+el.last)
// console.log(engineers)

//output will be same ["John Doe","ohn Foe","Rohn Xoe"]

// </script>
<script>
  // let fruits = ["Apple", "Orange", "Plum"];
// // same as fruits[fruits.length-1]
// alert( fruits.at(-1) ); // Plum



// shift
// Extracts the first element of the array and returns it

// let fruits = ["Apple", "Orange", "Pear"];

// alert( fruits.shift() ); // remove Apple and alert it

// alert( fruits ); // Orange, Pear
// unshift
// Add the element to the beginning of the array:

// let fruits = ["Orange", "Pear"];
// fruits.unshift('Apple');
// alert( fruits ); // Apple, Orange, Pear
</script>

<script>
//only strings and symbol are allowed to be a key of an object

// let a="john"
// let obj={

// }
// obj[a]="axz"
// console.log(obj)
//{john: 'axz'}

let a="john"
let obj={

}
obj['z']="axz"
console.log(obj)
//{z: 'axz'}
</script>

</html>

This Keyword

<script>
// there are two type of functions
// 1 Regular
// 2 Arraow


// Key Differences:
// this Binding:

// Regular functions have their own this binding, which is dynamically determined when the function is called.
// Arrow functions do not have their own this binding; instead, 
// they inherit the this value from the enclosing scope.
// Arguments Object:

// Regular functions have access to the arguments object, which is an array-like
//  object containing all the arguments passed to the function.
// Arrow functions do not have their own arguments object.
// Syntax:

// Arrow functions provide a more concise syntax, which can
//  be especially helpful for short, single-expression functions.
// Both regular functions and arrow functions are widely 
// used in JavaScript, and the choice between them depends on 
// the specific use case and requirements. Arrow functions are
//  commonly preferred for short, simple functions, while regular
//  functions may be more suitable for more complex scenarios or
//  when you need the dynamic this binding.






</script>











<script>
  // call, apply & bind 
// .call & .apply are used to invoke a function & set the value of the this keyword 
// inside of the function

// .bind is used to create a function & set the value of the this keyword 
// inside of the newly created function


function greet(greeting, year, receiver) {
  return `${greeting} ${year} to ${receiver} from ${this.name}.`
}

// while invoking greet() we need to set the value of this keyword inside 
// of the greet function

// .call()
// takes in the value of this keyword as the first argument
// rest of the arguments to the function can be sent as comma separated values
// let g =  greet.call({name: 'Vivek'}, 'Happy new year', '2023', 'JS201 Batch')

// .apply()
// takes in the value of this keyword as the first argument
// rest of the arguments to the function can be sent a an array of values

// let args = [];
// args.push('Happy new year');
// args.push('2023');
// args.push('JS201 Batch');

// let g =  greet.apply({name: 'Vivek'}, args)

// .bind()
// bind gives you a new function 
// in which the this keyword is pre-set for you
// let greetFromVivek = greet.bind({name: 'Vivek'});
// let g = greetFromVivek('Happy new year', '2023', 'JS201 Batch')

console.log(g)
</script>
<script>
  // .at(index) - Returns the element at the given index in the array.
[3, 4, 5, 6].at(1); // 4
// Example: Returns the element at index 1, which is `4`.
// Difference: Directly accesses an element without modifying the array.

// .pop() - Removes the last element from an array and returns it. This method mutates the original array.
let arr1 = [3, 4, 5, 6];
arr1.pop(); // 6
console.log(arr1); // [3, 4, 5]
// Example: Removes the last element (`6`), leaving `[3, 4, 5]`.
// Difference: Mutates the array by removing the last element.

// .push(element) - Adds one or more elements to the end of an array and returns the new length of the array. This method mutates the original array.
let arr2 = [3, 4, 5, 6];
arr2.push(7); // 5
console.log(arr2); // [3, 4, 5, 6, 7]
// Example: Adds `7` to the end, making it `[3, 4, 5, 6, 7]`.
// Difference: Mutates the array by adding elements to the end.

// .fill(value) - Fills all the elements of an array from a start index to an end index with a static value.
[3, 4, 5, 6].fill(1); // [1, 1, 1, 1]
// Example: Fills the array with `1`, resulting in `[1, 1, 1, 1]`.
// Difference: Replaces all elements with a specified value.

// .join(separator) - Joins all elements of an array into a string, separated by a specified separator.
[3, 4, 5, 6].join("-"); // '3-4-5-6'
// Example: Joins the elements with a hyphen, resulting in `'3-4-5-6'`.
// Difference: Converts the array into a string.

// .shift() - Removes the first element from an array and returns it. This method mutates the original array.
let arr3 = [3, 4, 5, 6];
arr3.shift(); // 3
console.log(arr3); // [4, 5, 6]
// Example: Removes the first element (`3`), leaving `[4, 5, 6]`.
// Difference: Mutates the array by removing the first element.

// .reverse() - Reverses the order of the elements in an array. This method mutates the original array.
let arr4 = [3, 4, 5, 6];
arr4.reverse(); // [6, 5, 4, 3]
// Example: Reverses the array to `[6, 5, 4, 3]`.
// Difference: Mutates the array by reversing the order of elements.

// .unshift(element) - Adds one or more elements to the beginning of an array and returns the new length of the array. This method mutates the original array.
let arr5 = [3, 4, 5, 6];
arr5.unshift(1); // 5
console.log(arr5); // [1, 3, 4, 5, 6]
// Example: Adds `1` to the beginning, making it `[1, 3, 4, 5, 6]`.
// Difference: Mutates the array by adding elements to the beginning.

// .includes(value) - Determines whether an array contains a certain value among its entries.
[3, 4, 5, 6].includes(5); // true
// Example: Checks if `5` is in the array, returning `true`.
// Difference: Checks for the presence of a value without modifying the array.

// .map(callback) - Creates a new array with the results of calling a provided function on every element in the calling array.
[3, 4, 5, 6].map((num) => num + 6); // [9, 10, 11, 12]
// Example: Adds `6` to each element, resulting in `[9, 10, 11, 12]`.
// Difference: Creates a new array without modifying the original array.

// .find(callback) - Returns the first element in the array that satisfies the provided testing function.
[3, 4, 5, 6].find((num) => num > 4); // 5
// Example: Finds the first element greater than `4`, which is `5`.
// Difference: Returns a single value based on a condition without modifying the array.

// .filter(callback) - Creates a new array with all elements that pass the test implemented by the provided function.
[3, 4, 5, 6].filter((num) => num > 4); // [5, 6]
// Example: Filters the array to elements greater than `4`, resulting in `[5, 6]`.
// Difference: Creates a new array with elements that meet a condition without modifying the original array.

// .every(callback) - Tests whether all elements in the array pass the test implemented by the provided function.
[3, 4, 5, 6].every((num) => num > 5); // false
// Example: Checks if every element is greater than `5`. Since not all elements are, it returns `false`.
// Difference: Returns a boolean based on a condition without modifying the array.

// .findIndex(callback) - Returns the index of the first element in the array that satisfies the provided testing function. Otherwise, it returns `-1`.
[3, 4, 5, 6].findIndex((num) => num > 4); // 2
// Example: Finds the index of the first element greater than `4`, which is `2`.
// Difference: Returns the index of the element based on a condition without modifying the array.

// .reduce(callback, initialValue) - Executes a reducer function (that you provide) on each element of the array, resulting in a single output value.
[3, 4, 5, 6].reduce((acc, num) => acc + num, 8); // 26
// Example: Sums all elements starting with the initial value `8`, resulting in `26`.
// Difference: Produces a single accumulated result without modifying the array.




</script>
<script>
//   Summary of Differences:
// Mutating vs. Non-Mutating Methods: Methods like .pop(), .push(), .shift(), .reverse(), .unshift(), and .fill() mutate the original array. In contrast, methods like 
// .at(), .includes(), .map(), .find(), .filter(), .every(), .findIndex(), .reduce(), and .join() do not mutate the original array.
// Return Types: Some methods return elements or values (.at(), .pop(), .shift(), .find(), .reduce(), .every(), .includes()), some return 
// arrays (.map(), .filter(), .reverse(), .push(), .unshift(), .fill()), and others return strings (.join()).
// Behavior: Some methods are used to add or remove elements (.push(), .pop(), .shift(), .unshift()), some to transform elements (.map(), 
// .fill()), some to check conditions (.every(), .includes()), some to find values or indices (.find(), .findIndex()), and some to aggregate results (.reduce()).
</script>

<script>
  // Define the fakeMap function
Array.prototype.fakeMap = function(callback) {
    // Create a new array to hold the results
    const result = [];
    // Loop through each element in the array
    for (let i = 0; i < this.length; i++) {
        // Apply the callback function to each element
        result.push(callback(this[i], i, this));
    }
    // Return the new array
    return result;
};

// Example usage of fakeMap
const originalArray = [3, 4, 5, 6];
const newArray = originalArray.fakeMap(num => num + 6);

console.log(newArray); // [9, 10, 11, 12]
console.log(originalArray); // [3, 4, 5, 6] - remains unchanged

</script>

<!-- Differences Between fakeMap and Native .map()
Performance and Optimization:

Native .map(): The native .map() method is highly optimized and implemented in low-level code within the JavaScript engine, making it faster and more efficient.
Custom fakeMap: The custom fakeMap implementation is written in JavaScript and may not be as optimized as the native method.
Edge Case Handling:

Native .map(): The native .map() method has built-in handling for various edge cases, such as sparse arrays (arrays with missing elements).
Custom fakeMap: The custom implementation may not handle all edge cases unless explicitly programmed to do so. For example, it does not handle sparse arrays out-of-the-box.
Method Availability:

Native .map(): The native .map() method is available on all arrays as part of the standard JavaScript Array prototype.
Custom fakeMap: The custom fakeMap method must be added to the Array prototype manually and is not available by default.
Error Handling:

Native .map(): The native .map() method includes robust error handling and validation.
Custom fakeMap: The custom implementation may require additional error handling to match the robustness of the native method.
Specification Compliance:

Native .map(): Fully compliant with the ECMAScript specification, ensuring consistent behavior across all JavaScript environments.
Custom fakeMap: Needs careful implementation to ensure it behaves consistently with the specification. There might be subtle differences if the implementation is not thorough.
Prototype Method:

Native .map(): Always part of the Array prototype.
Custom fakeMap: Needs to be explicitly added to the Array prototype. -->