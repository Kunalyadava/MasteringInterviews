<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <!-- Execution Context 
    📚 Callstack 
    🔢 Data types (Especially Arrays, Objects, Strings) 
    🔄 Array and Object methods 
    🔗 let/var/const 
    🕳️ Hoisting, Temporal Dead Zone 
    🚫 Illegal shadowing 
    🔍 Scope, Scope chaining 
    🔄 Mutable/Immutable data types 
    🔍 Shallow and Deep copy 
    🌐 DOM (DOM methods) and BOM 
    📝 Critical Rendering Path 
    🔧 Functions 
    📄 Function Declaration 
    🗣️ Function Expression 
    🔄 Functional Programming 
    ➡️ Arrow Functions 
    📦 IIFE 
    🔑 this keyword 
    ➡️ Arrow function and this keyword 
    📞 Call, Apply, Bind 
    🔒 Closure and its uses 
    🔄 Callbacks, Callback Hell 
    🔮 Promises, promise chaining 
    ⏳ Async/Await 
    🔄 Callbacks vs promises vs async/await 
    🍛 Currying 
    🛠️ Debouncing and Throttling 
    🔍 Event Propagation 
    🔵 Bubbling 
    🎣 Capturing 
    📦 Event Delegation 
    📘 Prototype and Prototypal Inheritance 
    🧠 Memoization 
    🌀 Generator Functions 
    🔄 Event Loop, Microtasks, Macrotasks 
    🎉 Events: DOMContentLoaded, load, beforeunload, unload 
    ⏩ async/defer 
    🩹 Polyfills (Mostly asked polyfills: Promise, Promise.all, Promise.any,
     Promise.race, Promise.allSettled, call, apply, bind, map, reduce, filter, forEach, flat, fetch API) 
    🌐 Web APIs 
    ⏲️ setTimeout, setInterval 
    🔄 High Order Functions 
    🔧 Working of JS Engine ... -->

    <span>
        <div>
            <!-- 📚 Execution Context -->
            <!-- Execution context is the environment in which JavaScript code is executed.
                 It includes the variable object, scope chain, and `this` keyword. -->
            <pre>
      function foo() {
        var a = 1;
        function bar() {
          var b = 2;
          console.log(a + b); // 3
        }
        bar();
      }
      foo();
        </pre>
        </div>

        <div>
            <!-- 🔢 Callstack -->
            <!-- Callstack is a mechanism to keep track of function calls in a program.
                 It operates in a LIFO (Last In, First Out) manner. -->
            <pre>
      function first() {
        second();
        console.log('First');
      }
      function second() {
        console.log('Second');
      }
      first(); // Output: Second, First
        </pre>
        </div>

        <div>
            <!-- 🔢 Data types (Especially Arrays, Objects, Strings) -->
            <!-- JavaScript has various data types including primitive types like Strings
                 and non-primitive types like Arrays and Objects. -->
            <pre>
      let str = "Hello";
      let arr = [1, 2, 3];
      let obj = { name: "John", age: 30 };
        </pre>
        </div>

        <div>
            <!-- 🔄 Array and Object methods -->
            <!-- Arrays and Objects come with built-in methods to manipulate their content. -->
            <pre>
      arr.push(4); // Adds an element to the end of the array [1, 2, 3, 4]
      Object.keys(obj); // Returns an array of the object's keys ["name", "age"]
        </pre>
        </div>

        <div>
            <!-- 🔗 let/var/const -->
            <!-- `var` is function-scoped while `let` and `const` are block-scoped.
                 `const` is used for constants. -->
            <pre>
      var a = 1;
      let b = 2;
      const c = 3;
        </pre>
        </div>

        <div>
            <!-- 🕳️ Hoisting, Temporal Dead Zone -->
            <!-- Hoisting is JavaScript's behavior of moving declarations to the top. 
                `let` and `const` are not initialized until their definition is evaluated,
                 leading to the TDZ (Temporal Dead Zone). -->
            <pre>
      console.log(a); // undefined (hoisted)
      var a = 1;
      
      console.log(b); // ReferenceError (TDZ)
      let b = 2;
        </pre>
        </div>

        <div>
            <!-- 🚫 Illegal shadowing -->
            <!-- Illegal shadowing occurs when a variable declared with `let` or `const` is shadowed 
                by a `var` declaration in the same scope. -->
            <pre>
      let a = 1;
      {
        let a = 2; // Legal
        var a = 3; // Illegal - SyntaxError
      }
        </pre>
        </div>

        <div>
            <!-- 🔍 Scope, Scope chaining -->
            <!-- Scope determines the visibility of variables. Scope chain is used to 
                resolve variable names in nested functions. -->
            <pre>
      let a = 1;
      function outer() {
        let b = 2;
        function inner() {
          let c = 3;
          console.log(a, b, c); // 1, 2, 3
        }
        inner();
      }
      outer();
        </pre>
        </div>

        <div>
            <!-- 🔄 Mutable/Immutable data types -->
            <!-- Mutable types (objects, arrays) can be changed after creation, 
                while immutable types (strings, numbers) cannot. -->
            <pre>
      let str = "hello";
      str[0] = "H"; // No effect
      console.log(str); // "hello"
      
      let arr = [1, 2, 3];
      arr[0] = 4;
      console.log(arr); // [4, 2, 3]
        </pre>
        </div>

        <div>
            <!-- 🔍 Shallow and Deep copy -->
            <!-- Shallow copy duplicates the immediate properties of an object, 
                while deep copy duplicates everything recursively. -->
            <pre>
      let obj = { a: 1, b: { c: 2 } };
      let shallowCopy = { ...obj }; // Shallow copy
      let deepCopy = JSON.parse(JSON.stringify(obj)); // Deep copy
        </pre>
        </div>

        <div>
            <!-- 🌐 DOM (DOM methods) and BOM -->
            <!-- DOM (Document Object Model) methods manipulate HTML elements.
                 BOM (Browser Object Model) methods interact with the browser. -->
            <pre>
      document.getElementById('myId').innerText = 'Hello'; // DOM method
      window.alert('Hello from BOM'); // BOM method
        </pre>
        </div>

        <div>
            <!-- 📝 Critical Rendering Path -->
            <!-- The critical rendering path is the sequence of steps the browser takes
                 to render a web page. It includes parsing HTML, CSS, and JavaScript. -->
            <pre>
      <!DOCTYPE html>
      <html>
      <head>
        <style>/* CSS */</style>
        <script>/* JavaScript */</script>
      </head>
      <body>
        <div id="content">Hello, world!</div>
      </body>
      </html>
        </pre>
        </div>

        <div>
            <!-- 🔧 Functions -->
            <!-- Functions are reusable blocks of code. -->
            <!-- 📄 Function Declaration -->
            <pre>
      function greet() {
        console.log('Hello');
      }
        </pre>
            <!-- 🗣️ Function Expression -->
            <pre>
      const greet = function() {
        console.log('Hello');
      };
        </pre>
        </div>

        <div>
            <!-- 🔄 Functional Programming -->
            <!-- Functional programming is a paradigm where functions are first-class 
                citizens and side-effects are minimized. -->
            <pre>
      const add = (x) => (y) => x + y;
      const addTwo = add(2);
      console.log(addTwo(3)); // 5
        </pre>
        </div>

        <div>
            <!-- ➡️ Arrow Functions -->
            <!-- Arrow functions provide a shorter syntax for writing functions 
                and do not have their own `this`. -->
            <pre>
      const add = (a, b) => a + b;
        </pre>
        </div>

        <div>
            <!-- 📦 IIFE -->
            <!-- Immediately Invoked Function Expression
                 is a function that runs as soon as it is defined. -->
            <pre>
      (function() {
        console.log('IIFE');
      })();
        </pre>
        </div>

        <div>
            <!-- 🔑 this keyword -->
            <!-- `this` refers to the object it belongs to. -->
            <pre>
      const obj = {
        name: "John",
        greet: function() {
          console.log(this.name);
        }
      };
      obj.greet(); // John
        </pre>
        </div>

        <div>
            <!-- ➡️ Arrow function and this keyword -->
            <!-- Arrow functions do not have their own `this` 
                context and inherit it from the enclosing scope. -->
            <pre>
      const obj = {
        name: "John",
        greet: () => {
          console.log(this.name); // `this` refers to the global object
        }
      };
      obj.greet(); // undefined
        </pre>
        </div>

        <div>
            <!-- 📞 Call, Apply, Bind -->
            <!-- These methods allow controlling the
                 `this` context of a function. -->
            <pre>
      const obj = { name: "John" };
      function greet() {
        console.log(this.name);
      }
      greet.call(obj); // John
      greet.apply(obj); // John
      const boundGreet = greet.bind(obj);
      boundGreet(); // John
        </pre>
        </div>

        <div>
            <!-- 🔒 Closure and its uses -->
            <!-- Closure is a feature where an inner
                 function has access to the outer function's variables. -->
            <pre>
      function makeCounter() {
        let count = 0;
        return function() {
          count++;
          return count;
        };
      }
      const counter = makeCounter();
      console.log(counter()); // 1
      console.log(counter()); // 2
        </pre>
        </div>

        <div>
            <!-- 🔄 Callbacks, Callback Hell -->
            <!-- Callbacks are functions passed as arguments 
                to other functions to be executed later. Callback hell 
                refers to nested callbacks that are hard to manage. -->
            <pre>
      function doSomething(callback) {
        setTimeout(() => {
          callback('Done');
        }, 1000);
      }
      doSomething((result) => {
        console.log(result); // Done
      });
        </pre>
        </div>

        <div>
            <!-- 🔮 Promises, promise chaining -->
            <!-- Promises represent the eventual completion or failure
                 of an asynchronous operation and allow chaining. -->
            <pre>
      const promise = new Promise((resolve, reject) => {
        setTimeout(() => {
          resolve('Done');
        }, 1000);
      });
      promise.then(result => {
        console.log(result); // Done
      });
        </pre>
        </div>

        <div>
            <!-- ⏳ Async/Await -->
            <!-- Async/await is syntactic sugar over promises 
                for writing asynchronous code. -->
            <pre>
      async function fetchData() {
        const response = await fetch('https://api.example.com/data');
        const data = await response.json();
        console.log(data);
      }
      fetchData();
        </pre>
        </div>

        <div>
            <!-- 🔄 Callbacks vs promises vs async/await -->
            <!-- Callbacks are traditional ways to handle async operations,
                 promises provide better readability and error handling, 
                 async/await offers even cleaner syntax. -->
            <pre>
      function callbackExample(callback) {
        setTimeout(() => callback('Done'), 1000);
      }
      callbackExample(result => console.log(result)); // Done
      
      const promiseExample = new Promise((resolve) => {
        setTimeout(() => resolve('Done'), 1000);
      });
      promiseExample.then(result => console.log(result)); // Done
      
      async function asyncAwaitExample() {
        const result = await new Promise((resolve) => {
          setTimeout(() => resolve('Done'), 1000);
        });
        console.log(result); // Done
      }
      asyncAwaitExample();
        </pre>
        </div>

        <div>
            <!-- 🍛 Currying -->
            <!-- Currying is a technique where a function 
                takes multiple arguments one at a time. -->
            <pre>
      const add = x => y => x + y;
      const addTwo = add(2);
      console.log(addTwo(3)); // 5
        </pre>
        </div>

        <div>
            <!-- 🛠️ Debouncing and Throttling -->
            <!-- Debouncing delays the execution of a function 
                until a certain time has passed. Throttling ensures 
                a function is called at most once in a specified time period. -->
            <pre>
      function debounce(func, wait) {
        let timeout;
        return function(...args) {
          clearTimeout(timeout);
          timeout = setTimeout(() => func.apply(this, args), wait);
        };
      }
      function throttle(func, limit) {
        let inThrottle;
        return function(...args) {
          if (!inThrottle) {
            func.apply(this, args);
            inThrottle = true;
            setTimeout(() => inThrottle = false, limit);
          }
        };
      }
        </pre>
        </div>

        <div>
            <!-- 🔍 Event Propagation -->
            <!-- Event propagation determines how 
                events flow through the DOM tree. -->
            <!-- 🔵 Bubbling -->
            <pre>
      document.getElementById('child').addEventListener('click', () => {
        console.log('Child clicked');
      });
      document.getElementById('parent').addEventListener('click', () => {
        console.log('Parent clicked');
      });
        </pre>
            <!-- 🎣 Capturing -->
            <pre>
      document.getElementById('child').addEventListener('click', () => {
        console.log('Child clicked');
      }, true);
      document.getElementById('parent').addEventListener('click', () => {
        console.log('Parent clicked');
      }, true);
        </pre>
        </div>

        <div>
            <!-- 📦 Event Delegation -->
            <!-- Event delegation allows handling events at a 
                higher level in the DOM instead of setting 
                event listeners for specific nodes. -->
            <pre>
      document.getElementById('parent').addEventListener('click', (event) => {
        if (event.target && event.target.matches('button')) {
          console.log('Button clicked');
        }
      });
        </pre>
        </div>

        <div>
            <!-- 📘 Prototype and Prototypal Inheritance -->
            <!-- JavaScript uses prototypes for inheritance.
                 Objects can inherit properties and methods 
                 from their prototype. -->
            <pre>
      function Person(name) {
        this.name = name;
      }
      Person.prototype.greet = function() {
        console.log(`Hello, ${this.name}`);
      };
      const john = new Person('John');
      john.greet(); // Hello, John
        </pre>
        </div>

        <div>
            <!-- 🧠 Memoization -->
            <!-- 
            Memoization is a technique used in programming to optimize the performance
            of functions by caching the results of expensive function calls and
            returning the cached result when the same inputs occur again.
            This can significantly reduce the time complexity of algorithms,
            especially those with overlapping subproblems,
            such as those found in dynamic programming. -->
            <pre>
      function memoize(fn) {
        const cache = {};
        return function(...args) {
          const key = JSON.stringify(args);
          if (cache[key]) {
            return cache[key];
          }
          const result = fn(...args);
          cache[key] = result;
          return result;
        };
      }
        </pre>
        </div>

        <div>
            <!-- 🌀 Generator Functions -->
            <!-- Generator functions can pause execution and resume
                 later, producing a sequence of values. -->
            <pre>
      function* generateSequence() {
        yield 1;
        yield 2;
        yield 3;
      }
      const generator = generateSequence();
      console.log(generator.next().value); // 1
      console.log(generator.next().value); // 2
      console.log(generator.next().value); // 3
        </pre>
        </div>

        <div>
            <!-- 🔄 Event Loop, Microtasks, Macrotasks -->
            <!-- The event loop handles execution of multiple pieces
                 of JavaScript code including microtasks (e.g., promises)
                  and macrotasks (e.g., setTimeout). -->
            <pre>
      console.log('Start');
      setTimeout(() => {
        console.log('Timeout');
      }, 0);
      Promise.resolve().then(() => {
        console.log('Promise');
      });
      console.log('End');
        </pre>
        </div>

        <div>
            <!-- 🎉 Events: DOMContentLoaded, load, beforeunload, unload -->
            <!-- These events indicate different stages of the page load process. -->
            <pre>
      document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM fully loaded and parsed');
      });
      window.addEventListener('load', () => {
        console.log('Page fully loaded');
      });
      window.addEventListener('beforeunload', (event) => {
        event.returnValue = 'Are you sure you want to leave?';
      });
      window.addEventListener('unload', () => {
        console.log('Page is unloading');
      });
        </pre>
        </div>

        <div>
            <!-- ⏩ async/defer -->
            <!-- `async` loads scripts asynchronously while 
                `defer` loads them after the document is parsed. -->
            <pre>
      <script async src="script.js"></script>
      <script defer src="script.js"></script>
        </pre>
        </div>

        <div>
            <!-- 🩹 Polyfills (Promise, Promise.all, Promise.any, 
                Promise.race, Promise.allSettled, call, apply, bind,
                 map, reduce, filter, forEach, flat, fetch API) -->
            <!-- Polyfills are used to add support for features
                 not available in certain environments. -->
            <pre>
      if (!window.Promise) {
        window.Promise = /* Polyfill code */;
      }
        </pre>
        </div>

        <div>
            <!-- 🌐 Web APIs -->
            <!-- Web APIs provide additional functionalities
                 like network requests, data storage, etc. -->
            <pre>
      const timeoutId = setTimeout(() => {
        console.log('Timeout');
      }, 1000);
      clearTimeout(timeoutId);
      
      const intervalId = setInterval(() => {
        console.log('Interval');
      }, 1000);
      clearInterval(intervalId);
        </pre>
        </div>

        <div>
            <!-- 🔄 High Order Functions -->
            <!-- High order functions take other 
                functions as arguments or return them. -->
            <pre>
      function higherOrderFunction(fn) {
        return function(...args) {
          return fn(...args);
        };
      }
      const double = higherOrderFunction(x => x * 2);
      console.log(double(2)); // 4
        </pre>
        </div>

        <div>
            <!-- 🔧 Working of JS Engine -->
            <!-- 1. Parsing: The JS engine parses the source 
                code into an Abstract Syntax Tree (AST). -->
            <!-- 2. Compilation: The engine compiles the AST into bytecode. -->
            <!-- 3. Execution: The bytecode is executed in the JavaScript runtime. -->
            <pre>
            console.log('JavaScript Concepts Explained');
        </pre>
        </div>
    </span>
</body>
<span>
    <!-- Document Object Model (DOM) is a programming interface for HTML
    and XML documents, that allows to create, manipulate,
    or delete the element from the document. It defines the
    logical structure of documents and the way a document
    is accessed and manipulated. With the help of DOM, the
    webpage can be represented in a structured hierarchy,
    i.e., we can easily access and manipulate tags, IDs,
    classes, Attributes, or Elements of HTML using
    commands or methods provided by the Document object,
    that will guide the programmers and users to
    understand the document in an easier manner.

    HTML is used to structure the web pages and Javascript is used to
    add behavior to our web pages. When an HTML file is
    loaded into the browser, the javascript can not understand
    the HTML document directly. So, a corresponding document is
    created(DOM). DOM is basically the representation of the
    same HTML document but in a different format with the use of
    objects. DOM provides several methods to find &
    manipulate the behavior of the HTML element:

    getElementById() Method: This method returns the
    elements that have given an ID which is passed to the function.
    getElementsByClassName() Method: This method in
    Javascript returns an object containing all the elements with the
    specified class names in the document as objects: This
    getElementsByName() Method: This method returns
    the collection of all elements of a particular document by name.
    getElementsByTagName() Method: This method in HTML returns the
    collection of all the elements in the document with the
    given tag name.
    querySelector() Method: This method in HTML is used to return the
    first element that matches a specified CSS selector(s)
    in the document.
    querySelectorAll() Method: This method is used to return a
    collection of an element’s child elements that match a
    specified CSS selector(s), as a static NodeList object.




    Browser Object Model (BOM) is a browser-specific convention
    referring to all the objects exposed by the web browser.
    The BOM allows JavaScript to “interact with” the browser.
    The window object represents a browser window and all its
    corresponding features. A window object is created automatically
    by the browser itself. Java Script’s window.screen object contains
    information about the user’s screen. It can also be written without
    the window prefix. This Object Model supports the following Window properties:

    screen.width: The screen.width property returns the user’s screen width in pixels.
    screen.height: The screen.height property returns the user’s screen height in pixels.
    screen.availWidth: The screen.availWidth property returns the user’s screen width
    in pixels, excluding the interface features.
    screen.availHeight: The screen.availHeight property returns the user’s screen
    height in pixels excluding the interface features.
    screen.colorDepth: The screen.colorDepth property returns
    the bits (number) to be used to display one color.
    screen.pixelDepth: The screen.pixelDepth property returns the pixel depth of the screen.
    The BOM also supports the following Window methods:

    window.open() Method: This method is used to open a new
    tab or window with the specified URL and name.
    window.close() Method: This method, is used for closing a
    certain window or tab of the browser which was previously
    opened by the window.open() method. -->


    <!-- Caching is a technique used in computing to store data
    temporarily so that future requests for that data can be
    served faster. It is a crucial optimization method for
    improving the performance and efficiency of various systems,
    including web servers, databases, and applications.

    Types of Caching
    Memory Cache: Stores data in the memory (RAM) for quick access.
       Commonly used in web browsers and applications.
    Disk Cache: Stores data on disk. It’s slower
       than memory cache but can handle larger amounts of data.
    Distributed Cache: Uses a distributed system to
       cache data across multiple servers. Useful for scaling applications. -->
</span>

<span>
    <!-- Converting Objects to Arrays
    1. Using Object.keys(), Object.values(), and Object.entries()
    Object.keys(obj): Returns an array of the object's own enumerable property names (keys).
    Object.values(obj): Returns an array of the object's own enumerable property values.
    Object.entries(obj): Returns an array of the object's own enumerable [key, value] pairs. -->
    <script>
        const obj = {
            name: "Alice",
            age: 30,
            address: {
                street: "123 Main St",
                city: "Wonderland"
            }
        };
        // Convert object keys to an array
        const keysArray = Object.keys(obj);
        console.log(keysArray); // ["name", "age", "address"]

        // Convert object values to an array
        const valuesArray = Object.values(obj);
        console.log(valuesArray); // ["Alice", 30, { street: "123 Main St", city: "Wonderland" }]

        // Convert object entries to an array of [key, value] pairs
        const entriesArray = Object.entries(obj);
        console.log(entriesArray); // [["name", "Alice"], ["age", 30], ["address", { street: "123 Main St", city: "Wonderland" }]]
    </script>
</span>
<span>
    <!-- Converting Arrays to Objects
    1. Using Array.prototype.reduce()
    You can use the reduce method to transform an array into an object.
    2. Using Object.fromEntries()
    Object.fromEntries is a more straightforward way to convert an array of
     [key, value] pairs back into an object. -->
</span>
<script>
    const keyValuePairs = [
        ["brand", "Toyota"],
        ["model", "Corolla"],
        ["year", 2020]
    ];

    // Using reduce
    const car = keyValuePairs.reduce((obj, [key, value]) => {
        obj[key] = value;
        return obj;
    }, {});

    console.log(car);
    // Output: { brand: "Toyota", model: "Corolla", year: 2020 }

    // Using Object.fromEntries
    const car2 = Object.fromEntries(keyValuePairs);
    console.log(car2);
    // Output: { brand: "Toyota", model: "Corolla", year: 2020 }

</script>

<span>
    forEach: Executes a provided function once for each array element. It doesn't create a new array but is used when
    you want to perform an operation for each element without needing to produce a new array as a result.

    map: Creates a new array by calling a provided function on every element in the array. It returns a new array with
    the results of calling the provided function on each element. It's useful when you want to transform each element of
    the array and produce a new array with the transformed elements.
</span>
<script>

// let arr=[1,2,3,4,5,6,7,]
// let arr2=arr.map((x)=>{
//     return x*2
// })
// console.log(arr2)


// let arr=[1,2,3,4,5,6,7,]
// let arr2=arr.filter((x)=>{
//     return x%2==0
// })
// console.log(arr2)

// let arr=[1,2,3,4,5,6,7,6]
// let arr2=[]
// arr.forEach((x)=>{
//     return arr2.push(x*2)
// })
// console.log(arr2)

</script>

</html>
<script>
    let person = {
        name: "Alice",
        age: 30,
        hobbies: ["reading", "hiking", "cooking"]
    };
    console.log("jsonString", JSON.stringify(person));
    //output=jsonString {"name":"Alice","age":30,"hobbies":["reading","hiking","cooking"]}

    let person2 = '{"name":"Alice","age":30,"hobbies":["reading","hiking","cooking"]}'
    console.log("jsonParse", JSON.parse(person2));

    //output

</script>

<script>
  // function currying(x) {
  //     return function (y) {
  //         return function (z) {
  //             return x + y + z;
  //         };
  //     };
  // }

  // const curriedFunction = currying(5)(2)(3);
  // console.log("curry", curriedFunction); // Outputs: "curry 10"
  // function currying(x,y,z){
  //     return x + y + z;
  // }
  // console.log("curry",currying(5,2,3))



  // Another way to use the curried function
  // const add5 = currying(5);
  // const add5And2 = add5(2);
  // const result = add5And2(3);
  // console.log("curry", result); // Outputs: "curry 10"
  // function currying(x,y,z){
  //     return x + y + z;
  // }
  // console.log("curry",currying(5,2,3))
  // function curry(x) {
  //     return function (y) {
  //         return function (z) {
  //             return x + y + z
  //         }
  //     }
  // }
  // console.log("curried",curry(5)(2)(2))

</script>
<script>
  console.log([1, 2, 3, 4].map((x) => (x > 3)))
  // Output: [false, false, false, true]
  //  The map function in JavaScript creates a new array
  //   populated with the results of calling a provided
  //     function on every element in the calling array.
  //    The function provided to map does not change the 
  //    values of the elements directly; instead, it 
  //    returns new values based on the computation
  //     within the function.

  // In  code console.log([1, 2, 3, 4].map((x) => (x > 3))),
  //         the provided function (x) => (x > 3) performs 
  //  a comparison operation that returns true or false
  //     for each element in the array. 
  //   Here is why it doesn't print 1, 2:

  // Original Array: [1, 2, 3, 4]

  // Mapping Function: (x) => (x > 3)

  // For x = 1: 1 > 3 evaluates to false
  // For x = 2: 2 > 3 evaluates to false
  // For x = 3: 3 > 3 evaluates to false
  // For x = 4: 4 > 3 evaluates to true
  // New Array: The map function collects these 
  // results and creates a new array:
  //     [false, false, false, true].

  // The key point is that map returns a new
  //     array based on the return values of the
  //     function provided for each element, not the 
  //     original elements themselves.Since the function
  //     (x > 3) only returns true or false, the resulting
  //     array contains boolean values, not the original numbers.

  // If you want to filter the array to include only
  //  numbers greater than 3, you should use the filter method instead:
  console.log([1, 2, 3, 4].filter((x) => (x > 3)));
  //Output: [4]
  //The filter method returns a new array with all elements that pass the
  //test implemented by the provided function,
  //which in this case are the numbers greater than 3.



  //Note: //if you want to use a function within map that checks certain
  //conditions and returns true or false based on those 
  //conditions, you can do so.The map function will then 
  //return an array of true and false values corresponding 
  //to each element in the original array. or 

  // if you want to conditionally include or exclude elements
  //  from the resulting array based on some criteria, 
  //  you can use a callback function with map(). 
  //  This callback function should return the new value
  //   for each element, or undefined if you want to exclude it.

  // const numbers = [1, 2, 3, 4, 5];
  // const evenNumbers = numbers.map(num => {
  //     if (num % 2 === 0) {
  //         return num;
  //     }
  // });
  // console.log(evenNumbers); // Output: [undefined, 2, undefined, 4, undefined]


  // The forEach method in JavaScript is used to execute a provided function
  //  once for each array element. Unlike map, forEach does not create a new array; 
  // it simply iterates over the array and performs the specified action for each element.
  //array.forEach(callback(currentValue, index, array), thisArg);
  // The provided callback function is executed once for 
  // each element in the array in ascending order. 
  // It doesn't modify the array directly 
  // (though it can modify the array elements if desired).

  const numbers = [1, 2, 3, 4, 5];
  numbers.forEach((number, index, array) => {
      array[index] = number * 2;
      console.log(`Index: ${index}, Value: ${array[index]}`);
  });
  // Logs the index and the modified value
  console.log(numbers);
  // Logs the final modified array
  // Index: 0, Value: 2
  // Index: 1, Value: 4
  // Index: 2, Value: 6
  // Index: 3, Value: 8
  // Index: 4, Value: 10
  // [2, 4, 6, 8, 10]


  // Nullish Coalescing Operator (??) and Logical OR Operator (||)

  // Nullish Coalescing Operator (??):
  // Purpose: Provides a default value if the original value is null or undefined.
  // Syntax: let result = leftOperand ?? rightOperand;
  // let a = null;
  // let b = '';
  // console.log(a ?? 'default'); // 'default'
  // console.log(b ?? 'default'); // ''

  // Logical OR Operator (||):
  // Purpose: Provides a default value if the original value is
  //  any falsy value (false, 0, -0, 0n, "", null, undefined, NaN).
  // Syntax: let result = leftOperand || rightOperand;
  // let a = null;
  // let b = '';
  // console.log(a || 'default'); // 'default'
  // console.log(b || 'default'); // 'default'
  // Key Differences:
  // ?? checks specifically for null or undefined.|| checks for any falsy value.
  // Use Cases:
  // Use ?? when you want to provide a default value only for
  //  null or undefined, allowing other falsy
  //   values (0, '', false, etc.) to be valid.
  // Use || when you want to provide a default
  //  value for any falsy value.


  // && (AND):

  // Returns the first falsy value encountered or the last value if all are truthy.
  // Short-circuits (stops evaluating) when a falsy value is found.
  // Commonly used to ensure multiple conditions are true before executing a block of code.
  // || (OR):

  // Returns the first truthy value encountered or the last value if all are falsy.
  // Short-circuits when a truthy value is found.
  // Commonly used to provide default values.
</script>

<!-- Minification is the process of reducing the size of a source code file by removing unnecessary characters and formatting
elements, without affecting its functionality. It is commonly used in web development and software distribution to
optimize file sizes for improved performance and user experience. Minification tools and build automation techniques
simplify the process and make it easy to incorporate into development workflows. -->

<body>
  <!-- JavaScript
  Definition: JavaScript is a high-level, interpreted programming language that is primarily used for client-side
  scripting in web browsers.
  Execution: JavaScript code is executed by JavaScript engines embedded in web browsers (such as V8 in Chrome,
  SpiderMonkey in Firefox, etc.).
  Process: JavaScript is typically written in plain text (source code), which is directly interpreted by the
  JavaScript engine. There is no separate compilation step like other languages that produce bytecode or
  binary code.
  Performance: Modern JavaScript engines often employ Just-In-Time (JIT) compilation to convert JavaScript code to
  machine code (binary code) on the fly for performance optimization.
  Example:
 
  console.log("Hello, World!");
  Use Case: Web development, including both client-side (browser) and server-side (with environments like Node.js). -->

  <!-- Typescript
  TypeScript is a Strongly Typed programming language that supports both dynamic and static typing. It provides
  classes, visibility scopes, namespaces, inheritance, unions, interfaces, and many other features.
  Also, it offers comments, variables,
  statements, expressions, modules, and functions.

  You can execute it on Node.Js or any other browser that supports ECMAScript 3 or its latest versions.
  Since TypeScript is an enhanced version of JavaScript, all code of JavaScript is syntactically valid TypeScript.
  However, it doesn’t mean the TypeScript compiler can process all JavaScript:
  let a = 'a'; a = 1; // throws: error TS2322: Type '1' is not assignable to type 'string'.

  Any & Unknown
  A type called Any (anything that you wish) can cover unknown
   is its type-safe system. Here, any allows you to assign
  and JavaScript variable whenever you want to escape the type system. 
  It’s widely used to describe incoming variables
  that haven’t been validated yet and whose type is
   unknown (for example, from third-party APIs).

  TypeScript supports abstraction through interfaces, while JavaScript does not.
  
  Unknown is similar to Any, but it will not allow you 
  to do anything with it unless it’s explicitly type-checked.?

  Void
  When there is no value returned, Void is used.
   Generally, it’s used for the return type of function that returns
  nothing.

  Never
  Never is the return type for something that
   should never happen, such as an exception-throwing function. -->

  <!-- 
  Static Typing
  Definition: In statically typed languages, type checking is performed at compile time,
   before the code is executed.

  Key Characteristics:

  Type Declarations: Variables must be explicitly declared
   with a type (e.g., int, string) when they are defined.

  Compile-Time Checking: The compiler checks the types of
   variables and expressions during compilation. Errors are
  caught early, before the program runs.

  Performance: Since type checking is done at compile time, 
  the runtime can be more optimized. The compiler can
  generate more efficient machine code.

  Error Detection: Type errors are detected early in the development
   process, which can prevent certain types of bugs
  from occurring at runtime.

  IDE Support: Static typing provides better support for 
  integrated development environments (IDEs) with features like
  autocomplete, refactoring, and type checking.
  Examples of Statically Typed Languages:

  Java
  C++
  C#
  Swift
  TypeScript (superset of JavaScript)
  
  Example:
  java
  Copy code
  int count = 10; // Declared as an integer
  count = "Hello"; // Compile-time error: Type mismatch
  Dynamic Typing
  Definition: In dynamically typed languages, type checking is performed at runtime, when the code is executed.

  Key Characteristics:

  Implicit Types: Variables are not explicitly declared with a type.
   The type is inferred from the value assigned to
  the variable.

  Runtime Checking: Types are checked during program execution.
   This allows for more flexible and expressive code but
  can lead to runtime errors.

  Flexibility: Dynamic typing allows for rapid prototyping and shorter code,
   as there is less need for explicit type
  declarations.

  Performance: Runtime type checking can introduce overhead,
   potentially making dynamically typed languages slower
  than statically typed ones.

  Error Detection: Type errors are caught only when the
   affected code paths are executed, which can make debugging
  more challenging.
  Examples of Dynamically Typed Languages:
  JavaScript
  Python
  Ruby
  PHP
  Perl

  Example:
  python
  count = 10 # Initially assigned an integer
  count = "Hello" # No error at assignment; type is changed to string
  print(count + 5) # Runtime error: Can't concatenate str and int

  Summary of Differences
  When Types Are Checked:


  Static Typing: At compile time.
  Dynamic Typing: At runtime.

  Type Declarations:
  Static Typing: Explicit type declarations are required.
  Dynamic Typing: Types are inferred and can change dynamically.
  Error Detection:
  Static Typing: Errors are caught during compilation, before execution.
  Dynamic Typing: Errors are caught during execution,
  which can lead to runtime crashes if not properly handled.
  Performance:
  Static Typing: Generally more efficient at runtime due to optimized machine code.
  Dynamic Typing: Can be less efficient due to the overhead of runtime type checking -->


  <!-- The difference between an interpreted and a compiled language lies in the result
   of the process of interpreting or compiling. An interpreter produces a result from 
   a program, while a compiler produces a program written in assembly language -->


</body>
<script>

  // function add(a, b) {
  //     return a + b
  //     setInterval(() => {
  //         console.log(((b, d) => {
  //             return b + d;
  //         })
  //             (2, 3))
  //     }, 1000)
  // }
  // add(2, 4)
  // console.log(add(2, 4))
  // In your provided code, the setInterval function is placed after
  //  the return statement in the add function. This means that the
  // return statement will exit the function immediately, and the
  //  code after it won't be executed. To correct this and make sure the setInterval
  // function works as expected, you should place it before the return statement

  // function add(a, b) {
  //     setInterval(() => {
  //         const result = (b, d) => {
  //             return b + d;
  //         };
  //         console.log(result(2, 3)); // This will log 5 every 1 second
  //     }, 1000);
  //     return a + b;
  // }
  // add(2, 4);

  // console.log("Time in");
  // let i = 0;
  // let id = setInterval(() => {
  //     console.log(i++);
  //     if (i === 10) {
  //         clearInterval(id);
  //         console.log("Timeout");
  //     }
  // }, 1000);
</script>

<script>
  
// Anonymous:

// Arrow Functions: Can be created without a name, often used for inline functions.
// Normal Functions: Typically named, which is useful for debugging and self-documenting code.
// Syntax:

// Arrow Functions: Use a more concise syntax (=>).
// Normal Functions: Use the traditional function keyword, resulting in more verbose code.
// Handling multiple expressions:

// Arrow Functions: Less intuitive when handling multiple statements due to needing explicit {} and return.
// Normal Functions: More straightforward when handling multiple statements.
// this keyword behavior:

// Arrow Functions: Lexically bind this, meaning they inherit this from the parent scope.
// Normal Functions: Bind this to the object that calls the function, making them useful for methods.
// Constructor functionality:

// Arrow Functions: Cannot be used as constructors and will throw an error if used with new.
// Normal Functions: Can be used as constructors with the new keyword to create instances.
// Arguments object:

// Arrow Functions: Do not have their own arguments object; use rest parameters (...args) instead.
// Normal Functions: Have their own arguments object, which is an array-like object accessible within the function.
// Duplicate named parameters:

// Arrow Functions: ES6 strict mode disallows duplicate named parameters in arrow functions.
// Normal Functions: Allow duplicate named parameters (not recommended, though).
// call, apply, and bind:

// Arrow Functions: The methods call, apply, and bind do not change the this value.
// Normal Functions: These methods can change the this value within the function.
// Scoping:

// Arrow Functions: Lexically scoped, which means the this value is determined
//     by the surrounding code context where the arrow function is defined.
// Normal Functions: Functionally scoped, meaning this is determined by how the function is called.

// Anonymous
const arrowGreet = () => {
  console.log("Hello from Arrow Function!");
};
function normalGreet() {
  console.log("Hello from Normal Function!");
}
arrowGreet(); // Output: Hello from Arrow Function!
normalGreet(); // Output: Hello from Normal Function!

// Syntax
const arrowAdd = (a, b) => a + b;
function normalAdd(a, b) {
  return a + b;
}
console.log(arrowAdd(2, 3)); // Output: 5
console.log(normalAdd(2, 3)); // Output: 5

// Handling Multiple Expressions
const arrowComplexOperation = (a, b) => {
  const result = a + b;
  return result * 2;
};
function normalComplexOperation(a, b) {
  const result = a + b;
  return result * 2;
}
console.log(arrowComplexOperation(2, 3)); // Output: 10
console.log(normalComplexOperation(2, 3)); // Output: 10

// `this` Keyword Behavior
const arrowObj = {
  value: 10,
  increment: () => {
    console.log(this.value); // undefined, inherits `this` from the global scope
  }
};
const normalObj = {
  value: 10,
  increment: function() {
    console.log(this.value); // 10, `this` refers to `normalObj`
  }
};
arrowObj.increment();
normalObj.increment();

// Constructor Functionality
const ArrowPerson = (name) => {
  this.name = name;
};
// const arrowPerson = new ArrowPerson("John"); // Error: ArrowPerson is not a constructor

function NormalPerson(name) {
  this.name = name;
}
const normalPerson = new NormalPerson("John");
console.log(normalPerson.name); // Output: John

// Arguments Object
const arrowShowArgs = (...args) => {
  console.log(args); // Uses rest parameters
};
 
arrowShowArgs(1, 2, 3); // Output: [1, 2, 3]
normalShowArgs(1, 2, 3); // Output: [Arguments] { '0': 1, '1': 2, '2': 3 }

// Duplicate Named Parameters
// const arrowFunc = (a, a) => a; // SyntaxError: Duplicate parameter name not allowed
function normalFunc(a, a) {
  return a;
}
console.log(normalFunc(1, 2)); // Output: 2

// `call`, `apply`, and `bind`
const arrowFuncCall = () => {
  console.log(this);
};
function normalFuncCall() {
  console.log(this);
}
arrowFuncCall.call({ name: "Alice" }); // Output: Window (or global object in Node.js)
normalFuncCall.call({ name: "Alice" }); // Output: { name: "Alice" }

// Scoping
const arrowOuterFunc = () => {
  return () => {
    console.log(this); // Inherits `this` from the arrowOuterFunc scope
  };
};
function normalOuterFunc() {
  return function() {
    console.log(this); // `this` is determined by the call
  };
}
arrowOuterFunc().call({ name: "Alice" }); // Output: Window (or global object in Node.js)
normalOuterFunc().call({ name: "Alice" }); // Output: { name: "Alice" }



/////

// mapfilterreduce
// forEach().map() -> No: forEach() doesn't return an array, so map() cannot be chained to it.
// map().forEach() -> Yes: Since map() returns an array, forEach() can be chained to iterate over the mapped array.
// filter().reduce() -> Yes: filter() returns an array, and reduce() can be chained to it to reduce the filtered array to a single value.
// map().filter() -> Yes: map() returns an array, and filter() can be chained to it to filter the mapped array.
// forEach().filter() -> No: forEach() doesn't return an array, so filter() cannot be chained to it.
const bag = [
  { title: "Apple" },
  { title: "Banana" },
  { title: "Orange" },
  { title: "Grapes" }
];
const e = "a"; // searching for titles containing 'a'
let newData = bag.filter((elem) => elem.title.toLowerCase().includes(e.toLowerCase()));
console.log(newData);
// Output: [
//   { title: "Apple" },
//   { title: "Banana" },
//   { title: "Orange" },
//   { title: "Grapes" }
// ]

// const bag = ["Apple", "Banana", "Orange", "Grapes"];
// const e = "a"; // searching for strings containing 'a'
// let newData = bag.filter((str) => str.toLowerCase().includes(e.toLowerCase()));
// console.log(newData);
// // Output: ["Apple", "Banana", "Orange", "Grapes" ]

// The includes method checks if an array contains a specific element.
//  It returns true if the element is found, and false
let fruits = ["apple", "banana", "mango", "orange"];
let hasMango = fruits.includes("mango");
console.log(hasMango); // Output: true

//deep.js

// Returning Functions (Closures):
// Functions in JavaScript can also return other functions. 
// This is often used to create closures, where the inner 
// function has access to the variables of the outer function 
// even after the outer function has finished executing.

function outer() {
  var a = 10;

  function inner() {
      console.log(a); // Accesses the 'a' variable from the outer function
  }
  return inner;
}
var closureFunction = outer();
closureFunction(); // Outputs: 10
// When closureFunction() is called, it:
// Executes the inner function.
// The inner function logs the value of a to the console.
// Since inner is a closure, it retains access to the variable
// a from the scope in which it was created, 
// which is the outer function's scope.

// outer() is called, and it returns the inner function.
// closureFunction holds the reference to the returned inner function.
// When closureFunction() is called, it executes the inner function.
// The inner function logs the value of a (which is 10) to the
//  console because it has access to the a variable through closure.
//

function outer() {
  var a = 10;
  function inner() {
      return a;
  }
  return inner;
}
console.log(outer()())//10
// When outer is called, it:

// Declares a variable a with the value 10.
// Defines an inner function inner that returns the value of a.
// Returns the inner function.
// Execution of the returned function:

// outer() returns the inner function.
// The returned inner function is then immediately invoked by the second pair of parentheses ().
// Return value of inner:
// return a;
// The inner function returns the value of a, which is 10.
// Output of console.log:
// console.log(outer()()) logs the return value of the inner function, which is 10



// ///
// function outer() {
//     var a = 10;

//     function inner() {
//         console.log(a);
//     }

//     return inner;
// }
// console.log(outer()())

// outer() is called, which returns the inner function.
// The returned inner function is immediately invoked.
// Inside inner, it logs the value of a (which is 10).
// The result of this process will be:

// 10
// undefined
// The undefined is the result of console.log(outer()()). 
// The inner function doesn't return a value; it only logs 
// the value of a. Therefore, the overall expression
//  console.log(outer()()) logs 10 from the inner function
//   and then undefined because inner doesn't return anything.


///

// function outer() {
//     var a = 10;
//     function inner() {
//         console.log(a);
//     }
//     return inner;
// }
// console.log(outer())

// ƒ inner() {
//     console.log(a);
// }
// This output is a string representation of the inner function,
//  indicating that outer() returned the inner function itself.


// const products = [
//     { id: 1, name: "Laptop", price: 1000 },
//     { id: 2, name: "Phone", price: 700 },
//     { id: 3, name: "Tablet", price: 500 }
//   ];
//   const laptop = console.log(products.find(product => product.name === "Laptop"));
// laptop is { id: 1, name: "Laptop", price: 1000 } 
// const WSort=products.sort((a,b)=>(a.price-b.price))
// console.log(WSort)
// console.log([1,2,56,76,3,4].sort((a,b)=>(a-b)))



//   Definition: The slice method returns a shallow copy of a portion of an array or string into 
//   a new array or string object selected from start to end (end not included).
//   The original array or string will not be modified.

// Syntax:

// For arrays: array.slice(start, end)
// For strings: string.slice(start, end)

// Parameters:
// start: The zero-based index at which to begin extraction.
// end (optional): The zero-based index before which to end extraction.
// The element at this index will not be included. If omitted,
// extraction goes till the end of the array/string.
// Examples:

// Array:
// let fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
// let citrus = fruits.slice(1, 3);
// // citrus contains ["Orange", "Lemon"]
// // fruits remains unchanged
// String:

// let text = "Hello World";
// let part = text.slice(0, 5);
// // part contains "Hello"
// // text remains unchanged
let arr3 = [1, 2, 3, 4, 5];
let result3 = arr.slice(2);  // Starts at index 2 and goes to the end of the array
console.log(result3);  // [3, 4, 5]
console.log(arr3);  // Original array is let arr = [10, 20, 30, 40, 50];

let result = arr.slice(1, 4);  // Starts at index 1, ends before index 4
console.log(result);  // [20, 30, 40]
console.log(arr);  // Original array is unchanged: [10, 20, 30, 40, 50]
unchanged: [1, 2, 3, 4, 5]
//start greater than end: If the start index is greater than the end index,
// slice returns an empty array.
//Negative start greater than end: If both indices are negative, it will still work 
//and return a portion of the array or string, but starting from the end.
// Splice
// Definition: The splice method changes the contents of an array by removing 
// or replacing existing elements and/or adding new elements in place. 
// This method directly modifies the original array.

// Syntax: array.splice(start, deleteCount, item1, item2, ...)

// Parameters:

// start: The index at which to start changing the array.
// deleteCount (optional): The number of elements to remove. If 0, no elements are removed.
// item1, item2, ... (optional): The elements to add to the array, beginning at the start index.
// Examples:

// Remove elements:

// let fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
// let removed = fruits.splice(2, 2);
// // removed contains ["Lemon", "Apple"]
// // fruits is now ["Banana", "Orange", "Mango"]
// Replace elements:

// let fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
// let replaced = fruits.splice(2, 1, "Grapes");
// // replaced contains ["Lemon"]
// // fruits is now ["Banana", "Orange", "Grapes", "Apple", "Mango"]
// Add elements:
// let fruits = ["Banana", "Orange", "Lemon", "Apple", "Mango"];
// fruits.splice(2, 0, "Kiwi", "Pineapple");
// // fruits is now ["Banana", "Orange", "Kiwi", "Pineapple", "Lemon", "Apple", "Mango"]
// Key Differences

// Purpose:
// slice is used for creating a new array or string without modifying the original.
// splice is used for adding/removing/replacing elements in an array, modifying the original array.

// Modification:
// slice does not modify the original array/string.
// splice modifies the original array.

// Return Value:
// slice returns a new array/string.
// splice returns an array containing the deleted elements.
let arr1 = [1, 2, 3, 4, 5];
let sliced = arr1.slice(1, 4);  // [2, 3, 4]
console.log(arr1);  // Original array is unchanged: [1, 2, 3, 4, 5]
///
let arr = [1, 2, 3, 4, 5];
let spliced = arr.splice(1, 2, 10, 20);  // Removes 2 and 3, adds 10 and 20
console.log(arr);  // Modified array: [1, 10, 20, 4, 5]
console.log(spliced);  // Deleted elements: [2, 3]

</script>


<!-- 
**1. Difference between `let`, `const`, and `var`:**
   - `var`: Function-scoped and can be redeclared. Variables declared with `var` are hoisted.
   - `let`: Block-scoped and cannot be redeclared within the same scope. Variables declared with 
   `let` are also hoisted but not initialized.
   - `const`: Block-scoped, cannot be redeclared or reassigned. `const` variables must be initialized at declaration.

**2. Hoisting in JavaScript:**
   - Hoisting allows variables and function declarations to be moved to the top of their scope before code execution.
    `var` variables are hoisted and initialized as `undefined`, while `let` and `const` are hoisted but not initialized.

**3. Closures:**
   - A closure is a function that remembers its lexical scope, even when the function is executed outside of
    its original scope. Closures allow functions to access variables from their outer scope.

**4. Event Loop in JavaScript:**
   - The event loop is a process that manages the execution of code, handling of events, and
    asynchronous operations in JavaScript. It continually checks the call stack and the callback queue, 
    moving tasks to the call stack when it’s empty.

**5. Difference between `==` and `===`:**
   - `==`: Performs type conversion before comparison (loose equality).
   - `===`: Compares both type and value without type conversion (strict equality).

**6. Checking the type of a variable:**
   - Use `typeof` to check a variable's type. Example: `typeof myVar`.

**7. Use of `this` in JavaScript:**
   - `this` refers to the object that is executing the current function. In the global context, 
   `this` refers to the global object, while in a method, it refers to the object calling the method.

**8. Function Declaration vs. Function Expression:**
   - Function Declaration: Defined with the `function` keyword and can be hoisted.
   - Function Expression: Assigned to a variable and is not hoisted.

**9. How `setTimeout` works:**
   - `setTimeout` schedules a function to execute after a specified delay. It moves the callback
    function to the callback queue after the delay, which will be executed when the call stack is empty.

---

**11. Callback Function:**
   - A callback is a function passed as an argument to another function, allowing it to be executed
    after the completion of that function.

**12. Pure Function:**
   - A function that, given the same inputs, always returns the same output and has no side effects.

**13. `function.call`, `function.apply`, and `function.bind`:**
   - `call`: Calls a function with a specified `this` value and arguments individually.
   - `apply`: Similar to `call` but takes arguments as an array.
   - `bind`: Returns a new function with a permanently bound `this` value.

**14. `arguments` object:**
   - An array-like object available inside functions that holds all arguments passed to the function.

**15. Creating a Closure:**
   - Create a closure by defining a function within another function and returning or using the inner function outside its lexical scope.

**16. `bind` Method:**
   - `bind` creates a new function with a specified `this` context, allowing the function to be called with that context regardless of its usual scope.

**17. Shallow Copy vs. Deep Copy:**
   - Shallow Copy: Copies references for nested objects. Modifications in the copy affect the original.
   - Deep Copy: Creates a copy of all nested objects, so changes do not affect the original.

**18. Call Stack:**
   - A data structure that stores the current execution context of functions. When a function is called, it’s pushed onto the stack, and when it returns, it’s popped off.

**19. Function Currying:**
   - A technique of transforming a function that takes multiple arguments into a series of functions that each take a single argument.

**20. Avoiding Callback Hell:**
   - Use Promises or `async/await` to handle asynchronous code in a more readable, sequential way.

---

**21. Prototypal Inheritance:**
   - A mechanism where objects inherit properties and methods from other objects through a prototype chain.

**22. Creating an Object:**
   - You can create an object using object literals, constructors, or `Object.create`.

**23. `prototype` Property:**
   - `prototype` is an object that every JavaScript function has. It allows inheritance of methods 
   and properties by other objects created from that function.

**24. `Object.create` vs. Constructor Pattern:**
   - `Object.create`: Creates a new object with a specified prototype.
   - Constructor Pattern: Uses a function to create and initialize an object, with the `new` keyword creating a new instance.

**25. Adding a Property to an Object:**
   - You can add a property using dot notation (`obj.prop = value`) or bracket notation (`obj['prop'] = value`).

**26. `hasOwnProperty` Method:**
   - Checks if a property is a direct property of an object, not inherited through the prototype chain.

**27. Preventing Object Modification:**
   - Use `Object.freeze` or `Object.seal` to prevent modification of an object’s properties.

**28. `new` Keyword:**
   - The `new` keyword creates an instance of an object based on a constructor function.

**29. Object Destructuring:**
   - Allows unpacking of values from objects or arrays into distinct variables. Example: `const {a, b} = obj;`

**30. Difference between `null` and `undefined`:**
   - `null`: Explicitly means "no value" and is assigned by the programmer.
   - `undefined`: Means a variable has been declared but not initialized.

---

**31. The DOM:**
   - The Document Object Model (DOM) is a representation of HTML elements as objects that can be manipulated by JavaScript.

**32. Selecting Elements in Vanilla JavaScript:**
   - Use methods like `document.getElementById`, `document.querySelector`, or `document.querySelectorAll` to select elements.

**33. `addEventListener` Method:**
   - Used to attach an event handler to an element. It allows multiple events on the same element.

**34. Event Delegation:**
   - A technique where a single event listener is added to a parent element to manage events on its child elements.

**35. Creating and Removing Elements:**
   - Use `document.createElement` to create elements, and `element.remove()` or `parent.removeChild(child)` to remove them.

**36. Event Propagation:**
   - Event propagation is the process by which events move through the DOM in phases: capturing, target, and bubbling.

**37. Preventing Default Behavior:**
   - Use `event.preventDefault()` to stop an event's default action, like form submission.

**38. `data-` Attribute:**
   - Custom attributes in HTML that store additional information on elements, accessible via JavaScript using `dataset`.

**39. `innerHTML` vs. `textContent`:**
   - `innerHTML`: Gets or sets the HTML markup of an element.
   - `textContent`: Gets or sets the text content, without parsing HTML tags.

**40. Handling Asynchronous Code:**
   - JavaScript provides multiple methods for handling asynchronous code, such as Promises, `async/await`, and callbacks. -->